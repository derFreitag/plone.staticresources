{"version":3,"file":"chunks/15244.0ff6a41249292129d86e.min.js","mappings":";gNAMIA,EAAMC,EAAAA,EAAAA,UAAkB,gBACxBC,EAAuB,QAEvBC,EAAWC,EAAAA,EAAAA,OAAY,CACvBC,KAAM,WACNC,QAAS,gBAETC,aACI,GAAIC,KAAKC,IAAIC,GAAGF,KAAKF,SAAU,CAK3B,IAAIK,EAASH,KAAKC,IAAIC,GAAG,UAAYF,KAAKC,IAAIG,MAAQJ,KAAKC,IAAII,cAC1CL,KAAKM,OAAOH,IACxBI,WAAWP,KAAKC,IAC5B,CACJ,EAEDF,aAAaM,GACT,MAAMG,SAAkB,uCAAoBC,QAG5CD,EAASE,WAAWC,SAAW,WAC3B,MAAO,CACH,CACIC,KAAM,SACNC,OAAQ,SAAUV,GACd,OAAOA,EAAOW,QAAQ,oBAAoB,SAAUC,EAAOC,GACvD,OAAIA,EACO,uEAEA,qCAEd,GACJ,GAGZ,EAED,MAAMC,EAAaC,IAAE,UACfC,EAAY,IAAIX,EAASY,UAAU,CACrCC,QAAQ,EACRX,WAAY,CAAC,cAGjB,OADAO,EAAWK,KAAKH,EAAUI,SAASlB,IAC5BY,CACV,EAEDlB,yBAAyByB,EAAKC,GAC1B,IAAIC,EACAvB,EAASsB,EACb,GAAID,EAAIrB,QAAuD,QAA5CuB,EAAS,aAAaC,KAAKH,EAAIrB,SAAmB,CAEjE,GAAe,QADfA,EAASH,KAAK4B,eAAezB,EAAQuB,EAAO,KAGxC,OADAlC,EAAIqC,KAAK,2BAA6BL,EAAIrB,OAAS,QAAUqB,EAAIM,KAC1DZ,IAAE,UAAUa,KAAK,WAAYP,EAAIM,KAE5C3B,GAAU,IACb,CAED,aADuBH,KAAKM,OAAOH,IACnB4B,KAAK,WAAYP,EAAIrB,OAASqB,EAAIM,IAAMN,EAAIrB,OAASqB,EAAIM,IAC5E,EAEDF,eAAevB,EAAMqB,GACjB,IAAIM,EAASC,EACbP,EAASQ,EAAAA,EAAAA,aAAmBR,GAC5B,IAAIS,EAAU,IAAIC,OACV,kDAAkDtB,QAC9C,UACAY,GAEJ,KAEJX,EAAQoB,EAAQR,KAAKtB,GACzB,GAAc,OAAVU,EACA,OAAO,KACJ,GAAIA,EAAM,GAEbkB,EAAQlB,EAAM,GAAGsB,OAGjBL,GAFAA,EACI,gFACclB,QAAQ,WAAYmB,OACnC,KAAIlB,EAAM,GAUb,OADAvB,EAAI8C,MAAM,kCAAmCvB,GACtC,KAPHiB,EADa,MAAbjB,EAAM,GAEF,qEAGA,uEAIX,CAOD,OANAiB,EAAUA,EAAQlB,QAAQ,UAAWY,GAGvB,QADdX,GADAoB,EAAU,IAAIC,OAAOJ,EAAS,MACdL,KAAKtB,KAEjBb,EAAI8C,MAAM,qDAEG,OAAVvB,EAAiBA,EAAM,GAAK,IACtC,IAGLG,IAAEqB,UAAUC,OAAM,WACdtB,IAAEqB,SAASE,MAAMC,GACb,yCACA,gBACA,WAIexB,IAAElB,MAAMyB,KAAK,cACnBkB,SAAQ,SAAUnB,GACf9B,EAAqBkD,KAAKpB,EAAIM,OAC9BN,EAAIqB,SAAW,WAEtB,GACJ,GAER,IAEDC,EAAAA,EAAAA,oBAA2B,WAAY,CACnC/C,cAAcgD,EAAMtB,GAChB,aAAauB,QAAQC,IACjBF,EAAKG,KAAInD,eAAgByB,GACrB,IAAI2B,EAAMxD,EAASyD,KAAK5B,EAAI6B,SAE5B,aADuBF,EAAIG,mBAAmB9B,EAAKC,EAEtD,IAER,IAGL,W","sources":["webpack://plone.staticresources/./node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["import $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["log","logging","is_markdown_resource","Markdown","Base","name","trigger","async","this","$el","is","source","val","text","render","replaceAll","Showdown","default","extensions","prettify","type","filter","replace","match","pre","$rendering","$","converter","Converter","tables","html","makeHtml","cfg","data","header","exec","extractSection","warn","url","attr","pattern","level","utils","matcher","RegExp","length","error","document","ready","body","on","forEach","test","dataType","inject","cfgs","Promise","all","map","pat","init","$target","renderForInjection"],"sourceRoot":""}